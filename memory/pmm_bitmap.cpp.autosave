#include "pmm.hpp"
#include "error_codes.hpp"
#include "../std/helper.hpp"
#include "../std/memory.hpp"
using namespace kernel;

// ~ BitmapPhysicalMemoryManagement

//void memory::BitmapPhysicalMemoryManagement::InitRegion(ulong base, size_t size)
//{
//    for(int blocks = size / BLOCK_SIZE, align = base / BLOCK_SIZE; blocks > 0; blocks--)
//    {
//        UnsetBit(align++);
//        used_blocks--;
//    }

//    SetBit(0);	//first block is always set. This insures allocs cant be 0
//}

//void memory::BitmapPhysicalMemoryManagement::DeinitRegion(ulong base, size_t size)
//{
//    for(int blocks = size / BLOCK_SIZE, align = base / BLOCK_SIZE; blocks > 0; blocks--)
//    {
//        SetBit(align++);
//        used_blocks++;
//    }

//    SetBit(0);	//first block is always set. This insures allocs cant be 0
//}

// ~ PhysicalMemoryManager

PhysicalMemoryManagementServer::PhysicalMemoryManagementServer() {}

PhysicalMemoryManagementServer::PhysicalMemoryManagementServer(multiboot::multiboot_info* multiboot_info, size_t memory_size)
{
    boot_info = multiboot_info;
    memory_map = VAR_TO_UINT_PTR(0x8000);
    pmm_memory_size = memory_size;
    max_blocks = pmm_memory_size / BLOCK_SIZE;
    used_blocks = max_blocks;
    memory_map_size =  max_blocks / BLOCK_SIZE;

    memset(memory_map, 0xF, memory_map_size);

    multiboot::multiboot_memory_map_t* mmap = reinterpret_cast<multiboot::multiboot_memory_map_t*>(boot_info->mmap_addr);
    while(reinterpret_cast<ulong>(mmap) < boot_info->mmap_addr + boot_info->mmap_length)
    {
        uint length = mmap->len;
        if(length <= 0)
        {
            //ignore entry
        }

        if(mmap->type == 1)
            InitRegion(mmap->addr, length);

        mmap = reinterpret_cast<multiboot::multiboot_memory_map_t*>(reinterpret_cast<ulong>(mmap) + mmap->size + sizeof(uint));
    }

    DeinitRegion(0x00100000, 0x100);
    DeinitRegion(reinterpret_cast<ulong>(memory_map), memory_map_size);
    DeinitRegion(0, 0x0010000);
}

PhysicalMemoryManagementServer::~PhysicalMemoryManagementServer()
{
    memset(memory_map, 0xF, memory_map_size);
}

int PhysicalMemoryManagementServer::DetectMemory(memory::smap_entry* buffer, int max_entries)
{
    uint id = 0;
    int entry = 0, signature, bytes;
    do
    {
        __asm__ __volatile__("int $0x15" : "=a"(signature), "=c"(bytes), "=b"(id)
                                         : "a"(0xE820), "b"(id), "c"(24), "d"(SMAP_SIGNATURE), "D"(buffer));
        if(signature != SMAP_SIGNATURE)
            return -1;

        if(bytes > 20 && (buffer->acpi & 0x0001) == 0)
        {
            //ignore entry
        }
        else
        {
            buffer++;
            entry++;
        }
    }
    while(id != 0 && entry < max_entries);

    return entry;
}

int PhysicalMemoryManagementServer::FindFirstFreeBit()
{
    for(uint i = 0; i < GetBlockSize() / 32; i++)
    {
        if(memory_map[i] != 0xFFFFFFFF)
        {
            for(int j = 0; j < 32; j++)
            {
                // ! test each bit in the dword
                int bit = 1 << j;
                if(!(memory_map[i] & bit) )
                    return i * 4 * 8 + j;
            }
        }
    }
    return -1;
}

int PhysicalMemoryManagementServer::FindFirstFreeBit(size_t number_of_blocks)
{
    if(number_of_blocks == 0)
        return -1;

    if(number_of_blocks == 1)
        return FindFirstFreeBit();

    for(uint i = 0; i < BLOCK_SIZE; i++)
    {
        if(memory_map[i] != 0xffffffff)
        {
            for(int j = 0; j < 32; j++)
            {                                       	// test each bit in the dword
                int bit = 1 << j;
                if(!(memory_map[i] & bit))
                {
                    int starting_bit = i * 32;
                    starting_bit += bit;	           	//get the free bit in the dword at index i

                    uint free = 0;                      //loop through each bit to see if its enough space
                    for(uint count = 0; count <= number_of_blocks; count++)
                    {
                        if(!TestBit(starting_bit + count))
                            free++;	                    // this bit is clear (free frame)

                        if(free == number_of_blocks)
                            return i * 4 * 8 + j;       //free count == number_of_blocks needed; return index
                    }
                }
            }
        }
    }
    return -1;
}

void PhysicalMemoryManagementServer::InitRegion(ulong base, size_t size)
{
    for(int blocks = size / BLOCK_SIZE, align = base / BLOCK_SIZE; blocks > 0; blocks--)
    {
        UnsetBit(align++);
        used_blocks--;
    }

    SetBit(0);	//first block is always set. This insures allocs cant be 0
}

void PhysicalMemoryManagementServer::DeinitRegion(ulong base, size_t size)
{
    for(int blocks = size / BLOCK_SIZE, align = base / BLOCK_SIZE; blocks > 0; blocks--)
    {
        SetBit(align++);
        used_blocks++;
    }

    SetBit(0);	//first block is always set. This insures allocs cant be 0
}

void* PhysicalMemoryManagementServer::AllocateBlock()
{
    uint free_blocks = GetFreeBlocks();
    if(free_blocks <= 0)
    {
        SetErrorCode(ERROR_PMM_NO_FREE_BLOCKS, PMM | ALLOCATEBLOCK);
        return nullptr;
    }

    uint frame = FindFirstFreeBit();
    if(frame == -1)
    {
        SetErrorCode(ERROR_PMM_OUT_OF_MEMORY, PMM | ALLOCATEBLOCK);
        return nullptr;
    }

    SetBit(frame);

    uint temp_address = frame * BLOCK_SIZE;
    used_blocks++;

    return reinterpret_cast<void*>(temp_address);
}

void* PhysicalMemoryManagementServer::AllocateBlocks(ulong number_of_blocks)
{
    uint free_blocks = GetFreeBlocks();
    if(free_blocks <= number_of_blocks)
    {
        SetErrorCode(ERROR_PMM_NO_FREE_BLOCKS, PMM | ALLOCATEBLOCKS);
        return nullptr;
    }

    int frame = FindFirstFreeBit(number_of_blocks);
    if(frame == -1)
    {
        SetErrorCode(ERROR_PMM_OUT_OF_MEMORY, PMM | ALLOCATEBLOCKS);
        return nullptr;
    }

    for(uint i = 0; i < number_of_blocks; i++)
        SetBit(frame + i);

    uint temp_address = frame * BLOCK_SIZE;
    used_blocks += number_of_blocks;

    return reinterpret_cast<void*>(temp_address);
}

void PhysicalMemoryManagementServer::FreeBlock(void* block_address)
{
    ulong temp_address = reinterpret_cast<ulong>(block_address);
    int frame = temp_address / BLOCK_SIZE;

    UnsetBit(frame);

    used_blocks--;
}

void PhysicalMemoryManagementServer::FreeBlocks(void* block_address, ulong number_of_blocks)
{
    ulong temp_address = reinterpret_cast<ulong>(block_address);
    int frame = temp_address / BLOCK_SIZE;

    for (uint i = 0; i < number_of_blocks; i++)
        UnsetBit(frame + i);

    used_blocks -= number_of_blocks;
}